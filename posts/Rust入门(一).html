<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Rust入门(一) | kihara</title><meta name="author" content="Kihara Ri"><meta name="copyright" content="Kihara Ri"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Rust入门(一)Rust核心机制(二)       最近听说Rust是一门最近几年非常热门的语言，它结合了大量语言的优点，有媲美C&#x2F;C++的性能，还更易于管理，安全性和易用性都很强，更是有着语言自身的特性，究竟是怎么回事，还得学习后作出自己的判断 以下的学习过程参照的是Rust的官方教程，粗略一读发现它写的非常详细，很适合新手入门，恨不得把知识塞到你嘴里赶紧用Rust开发程序了 Referenc">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust入门(一)">
<meta property="og:url" content="https://limuyuan.top/posts/Rust%E5%85%A5%E9%97%A8(%E4%B8%80).html">
<meta property="og:site_name" content="kihara">
<meta property="og:description" content="Rust入门(一)Rust核心机制(二)       最近听说Rust是一门最近几年非常热门的语言，它结合了大量语言的优点，有媲美C&#x2F;C++的性能，还更易于管理，安全性和易用性都很强，更是有着语言自身的特性，究竟是怎么回事，还得学习后作出自己的判断 以下的学习过程参照的是Rust的官方教程，粗略一读发现它写的非常详细，很适合新手入门，恨不得把知识塞到你嘴里赶紧用Rust开发程序了 Referenc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.rust-lang.org/static/images/rust-logo-blk.svg">
<meta property="article:published_time" content="2024-03-22T15:56:25.000Z">
<meta property="article:modified_time" content="2024-04-04T12:46:21.582Z">
<meta property="article:author" content="Kihara Ri">
<meta property="article:tag" content="Rust">
<meta property="article:tag" content="programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.rust-lang.org/static/images/rust-logo-blk.svg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://limuyuan.top/posts/Rust%E5%85%A5%E9%97%A8(%E4%B8%80).html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Kihara Ri","link":"链接: ","source":"来源: kihara","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#87428a","bgDark":"#1f1f1f","position":"bottom-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Rust入门(一)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-04 20:46:21'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 8 || hour >= 21
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4386068_in4cqueq0kl.css"><script src="/js/icon-import.js"></script><link rel="stylesheet" href="/css/icon-import.css"><script src="/js/githubcalendar.js"></script><link rel="stylesheet" href="/css/hometop.css"><script src="/js/hometop.js"></script><link rel="stylesheet" href="/css/side-bars.css"><link rel="stylesheet" href="/css/theme-color-val.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/Avator.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">102</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont hexo-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 兴趣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw iconfont hexo-bilibili"></i><span> 动画</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw iconfont hexo-books"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw iconfont hexo-film"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/info/"><i class="fa-fw iconfont hexo-circle-info"></i><span> Info</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont hexo-personal"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.rust-lang.org/static/images/rust-logo-blk.svg')"><nav id="nav"><span id="blog-info"><a href="/" title="kihara"><img class="site-icon" src="/img/Avator.png"/><span class="site-name">kihara</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont hexo-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 兴趣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw iconfont hexo-bilibili"></i><span> 动画</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw iconfont hexo-books"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw iconfont hexo-film"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/info/"><i class="fa-fw iconfont hexo-circle-info"></i><span> Info</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont hexo-personal"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Rust入门(一)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-22T15:56:25.000Z" title="发表于 2024-03-22 23:56:25">2024-03-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-04T12:46:21.582Z" title="更新于 2024-04-04 20:46:21">2024-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/logs/">logs</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ol><li><a href="/posts/Rust%E5%85%A5%E9%97%A8(%E4%B8%80).html" title="Rust入门(一)">Rust入门(一)</a></li><li><a href="/posts/Rust%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6(%E4%BA%8C).html" title="Rust核心机制(二)">Rust核心机制(二)</a></li></ol>

<div style="text-align: center">
<img src="https://www.rust-lang.org/static/images/rust-logo-blk.svg" style="display: inline-block; vertical-align= middle;">
<img src="https://mdstore.oss-cn-beijing.aliyuncs.com/markdown/rust_crab_logo.png" style="zoom: 12%; display: inline-block; vertical-align= middle;">
</div>

<p>最近听说Rust是一门最近几年非常热门的语言，它结合了大量语言的优点，有媲美C/C++的性能，还更易于管理，安全性和易用性都很强，更是有着语言自身的特性，究竟是怎么回事，还得学习后作出自己的判断</p>
<p>以下的学习过程参照的是Rust的<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/">官方教程</a>，粗略一读发现它写的非常详细，很适合新手入门，恨不得把知识塞到你嘴里赶紧用Rust开发程序了</p>
<h2 id="references">References</h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a></li>
<li><a target="_blank" rel="noopener" href="https://rustycab.github.io/LearnRustEasy/">https://rustycab.github.io/LearnRustEasy/</a></li>
</ol>
<h2 id="getting-started">Getting Started</h2>
<h3 id="installation">Installation</h3>
<p>在Linux/macOS下安装Rust可以说是非常方便了，只需下面一条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --proto <span class="string">'=https'</span> --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>

<p>确保能使用命令<code>rustc</code>，如果提示找不到命令，在<code>~/.zshrc</code>中加入路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="comment"># 加入环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$HOME</span>/.cargo/bin:<span class="variable">$PATH</span>"</span></span><br></pre></td></tr></table></figure>

<h3 id="hello-world">Hello, World!</h3>
<p>创建目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> Rust_projects</span><br><span class="line"><span class="built_in">cd</span> Rust_projects</span><br><span class="line"><span class="built_in">mkdir</span> hello_world</span><br><span class="line"><span class="built_in">cd</span> hello_world</span><br></pre></td></tr></table></figure>

<p>创建<code>main.rs</code>写下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>使用<code>rustc</code>编译文件并执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustc main.rs</span><br><span class="line">./main</span><br><span class="line">&gt; Hello, world!</span><br></pre></td></tr></table></figure>

<h3 id="hello-cargo">Hello, Cargo!</h3>
<p><code>Cargo</code>是Rust的包管理工具</p>
<p>查看是否能够正常使用Cargo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo --version</span><br></pre></td></tr></table></figure>

<p><strong>Creating a Prohect with Cargo</strong></p>
<p>回到项目目录，用下面的命令来创建一个带有<code>cargo</code>的项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo new hello_cargo</span><br><span class="line"><span class="built_in">cd</span> hello_cargo</span><br></pre></td></tr></table></figure>

<p>其中会产生一个<code>toml</code>文件(Tom’s Obvious, Minimal
Language)，这是<code>cargo</code>的配置信息格式</p>
<p>源代码会保存在<code>src</code>文件夹下，但是你不必在这个目录下使用刚刚的方式编译，只需留在项目目录下使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>

<p>因为默认的<code>build</code>是<code>debug build</code>，cargo会将这个二进制文件放在<code>debug</code>目录下，需要到这个目录下执行文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./target/debug/hello_cargo</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>这略微有点麻烦，使用以下命令进行编译和执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>

<p>检查是否能编译，但是不生成可执行文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo check</span><br></pre></td></tr></table></figure>

<p>这种方法能够快速检查代码是否有错误，如果生成可执行文件，对于一个大项目来说需要耗费很多时间，因此在持续性地写代码时，用这种方法做检查效率更高</p>
<p>简而言之：</p>
<ul>
<li>创建新项目<code>cargo new</code></li>
<li>生成项目<code>cargo build</code></li>
<li>生成并执行<code>cargo run</code></li>
<li>检查<code>cargo check</code></li>
<li>查找build到<code>target/debug</code>目录下</li>
</ul>
<p>如果要发布（当然这对现在的我们来说不重要），使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>

<p>这样编译会进行优化，让代码执行得更快，同时编译时间也会增加</p>
<h2 id="programming-a-guessing-game">Programming a Guessing Game</h2>
<h3 id="输入输出">输入输出</h3>
<p>首先先创建一个新项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo new guessing_game</span><br><span class="line"><span class="built_in">cd</span> guessing_game</span><br></pre></td></tr></table></figure>

<p>然后我们在<code>src/main.rs</code>下写下我们的代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"猜数字游戏"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"输入你猜的数字..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">"读取失败"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"你猜的数字是：{guess}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>为了获取用户输入和打印结果作为输出，我们引用了<code>io</code>，即input/output
library，以这种形式</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br></pre></td></tr></table></figure>

<p>Rust在标准库中定义了很多东西，每个程序都能默认调用，被称为<em>预设prelude</em>，可以在它的标准库文档中看到所有的内容，如果库不在预设中，你就需要额外引入，采用<code>use</code>的声明方法</p>
<p><code>println!()</code>是一个宏(macro)，接受参数将字符串打印到屏幕上</p>
<p><strong>创建变量来存储用户输入</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<p>这里的<code>let</code>是创建变量的声明，在Rust中变量在默认情况下是不可变的(immutable)，细节会在后面说明，但是目前我们只需要知道这么多</p>
<p>我们在变量名称前加上<code>mut</code>，就可以使变量可变(mutable)</p>
<p>右边是<code>guess</code>变量被绑定的值，这时调用<code>String::new</code>函数的结果，它会返回一个String的新实例，String类型是一段可增长的UTF-8编码的文本。<code>::</code>语法表示<code>new</code>是<code>String</code>类型的一个关联函数，<code>new</code>函数会创建一个新的空字符串</p>
<p><strong>接受用户输入</strong></p>
<p>调用<code>stdin</code>函数来允许处理用户输入</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">    .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br></pre></td></tr></table></figure>

<p>即使我们没有声明<code>use std::io</code>，我们也可以用这种方式来调用函数<code>std::io::stdin</code>，这一点和C++一样，<code>stdin</code>返回了<code>std::io::stdin</code>的实例(instance)，这是一种表示终端标准输入的句柄(handle)类型</p>
<p><code>read_line(&amp;mut guess)</code>调用了<code>read_line</code>方法来获取用户输入的handle，将<code>&amp;mut guess</code>作为参数传递给<code>read_line</code></p>
<p>在这里<code>&amp;</code>和C++一样，都表达了引用(reference)，它的功能是让你的代码的多个部分都能访问一个数据片段，而不需要多次将这个数据复制到内存中。默认情况下引用和变量都是不可变的，因此要写<code>&amp;mut guess</code>，具体原因会在后面的内容详细说明</p>
<p><strong>处理潜在的错误</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">.<span class="title function_ invoke__">expect</span>(<span class="string">"读取失败"</span>);</span><br></pre></td></tr></table></figure>

<p>注意这里空了四个空格(官方文档中也说明indent是用四个空格而不是Tab的)，用来表示它仍然是当个逻辑代码行的一部分</p>
<p>我们也可以这样写</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">io::<span class="title function_ invoke__">std</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess).<span class="title function_ invoke__">expect</span>(<span class="string">"读取失败"</span>);</span><br></pre></td></tr></table></figure>

<p>这是代码的完整形式，缺点是比较难读</p>
<p><code>read_line</code>做的事不仅是将用户输入的内容放入我们传递给他的字符串中，它还会返回一个<code>Result</code>值，<code>Result</code>实际上是一个枚举(enumeration)，它是一个可以处于多个可能状态中的一个类型，当然返回的是一个确定的，不然这不就跟量子力学一样了么（笑），对于每一个可能的状态，我们称为变体(variant)</p>
<p>事实上，<code>Result</code>只有两种变体，也就是两种状态，<code>Ok</code>和<code>Err</code>，<code>Result</code>的实例具有<code>expect</code>方法，如果<code>Result</code>实例返回的值是<code>Err</code>，<code>expect</code>将会导致程序崩溃</p>
<p>如果不调用<code>expect</code>，程序可以编译，但是会受到警告，尚未使用<code>read_line</code>返回的<code>Result</code>值，表明程序没有应对错误的方法。一般情况下，当出现问题时，我们只要程序崩溃就可以了，因此可以使用<code>expect</code></p>
<p>下面的打印和Python的方法非常相似，不多介绍</p>
<h3 id="生成随机数">生成随机数</h3>
<p>首先我们需要在依赖处引入<code>rand</code>库，打开<code>toml</code>文件，加入</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">"0.8.5"</span></span><br></pre></td></tr></table></figure>

<p>之后使用<code>cargo build</code>我们就可以看到Rust自动加载了这个库</p>
<p>声明<code>rand</code>库</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng</span><br></pre></td></tr></table></figure>

<p>给<code>secret_number</code>赋值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这里我们调用了<code>rand::thread_rng</code>函数来提供特定的随机数生成器，然后我们在这个生成器上调用<code>gen_range</code>方法</p>
<p><code>gen_range</code>方法接受的参数形式<code>start..=end</code></p>
<h3 id="比较">比较</h3>
<p>我们引入标准库的一个类型(type)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering</span><br></pre></td></tr></table></figure>

<p>这个type也是一种枚举，有三种变体<code>Less</code>,
<code>Greater</code>,<code>Equal</code></p>
<p>然后在后面加上</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) {</span><br><span class="line">        Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">"guess &lt; secret_number"</span>),</span><br><span class="line">        Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">"guess &gt; secret_number"</span>),</span><br><span class="line">        Ordering::Equal =&gt; <span class="built_in">println!</span>(<span class="string">"You won"</span>),</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>

<p>使用<code>cmp</code>方法来比较两个值，这需要调用你需要比较的内容的引用，就好像我们要用某一件物品，我们不需要拿它的原件，只需要用复印件就可以了</p>
<p>下面的三种情况就是<code>Ordering</code>的三种变体，我们使用<code>match</code>表达式来决定下一步应该做什么，当对应某一种情况时进行相应的操作</p>
<p>这里值的传递逻辑需要思考一下</p>
<p>但是，<strong>需要注意</strong>这仍然不能让代码成功运行起来，尽管逻辑看上去正确，但实际上，Rust具有类型推断的功能，我们定义<code>let mut guess = String::new()</code>的时候，Rust就能推断出<code>guess</code>是一个<code>String</code>，而<code>secret_number</code>是数字类型，因此无法进行比较</p>
<p>所以我们需要将<code>guess</code>转换成32位数字<code>u32</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">"请输入数字"</span>);</span><br></pre></td></tr></table></figure>

<p>在这里，我们又一次创建了变量<code>guess</code>，但是注意之前我们已经有了一个<code>guess</code>。这里Rust的机制<em>shadowing</em>允许我们通过重用变量名称来覆盖之前的值，这种方法常用来将值从一种类型转换为另一种类型</p>
<p>我们将新变量绑定到<code>guess.trim().parse()</code>，这里<code>trim()</code>函数用来去除开头和结尾的空格，因为我们在使用<code>read_line</code>时必须加上回车，这就回让字符串添加一个换行符。加入你输入了<code>5</code>，为了确认，你需要按下<code>enter</code>，因此最终保存的字符串其实是<code>5\n</code>(如果在Windows上则为<code>\r\n</code>)，而<code>trim</code>正是用来消除这个的，让最终结果仅为<code>5</code></p>
<p><code>parse</code>方法用来将字符串转换为另一种类型，如果在python中我们肯定会想到通过<code>parse()</code>括号中的内容来传递参数，但是在Rust中我们通过<code>let guess: u32</code>这个冒号告诉Rust变量的类型</p>
<p>现在告诉了<code>guess</code>是一个<code>u32</code>，Rust也会通过比较推断出<code>secret_number</code>也是一个<code>u32</code></p>
<p>此外，由于<code>parse</code>方法潜在的错误，仅适用于逻辑上可以转换为数字的字符，如果传入不可转换成数字的字符则会导致失败，像我们之前处理<code>read_line</code>一样加入故障处理<code>expect</code>即可</p>
<p>到这里，我们就可以用<code>cargo run</code>正确地运行了！</p>
<h3 id="循环">循环</h3>
<p>因为我们的小游戏需要不断猜测，以让用户有多次机会猜出数字，我们需要使用<code>loop</code>创建循环，使用<code>loop {}</code>包住循环体就可以了，但是需要注意的是，里面的代码必须带有缩进<code>indent = 4</code>四个空格</p>
<p>现在我们成功创建了循环，但是即使我们猜到了正确答案，也没有手段退出，当然使用<code>control + C</code>是可以强制退出的</p>
<p>要在程序中写入退出逻辑，直接在正确结果后加上<code>break</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Ordering::Equal =&gt; {</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"You won"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br></pre></td></tr></table></figure>

<h3 id="处理无效输入">处理无效输入</h3>
<p>之前的程序中，我们输入非数字时会导致程序崩溃，现在我们需要增加忽略逻辑</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() {</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        };</span><br></pre></td></tr></table></figure>

<p>在这个逻辑中<code>Err(_)</code>中的下划线(underscore)是一个通配符(catchall
value)，也就是说无论<code>Err</code>中有什么信息，都只要继续执行程序就可以了。但实际上，这可能导致程序忽略掉<code>parse</code>可能遇到的<strong>所有</strong>错误</p>
<h3 id="overview">Overview</h3>
<p>至此我们就完成了小游戏的全部代码，我从中不禁感觉到Rust语言在语法上的奇特，和它对错误处理的执拗。你每进行一个操作，都需要考虑到潜在的错误，这也是我能够在官方教程中明显感受到的</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"猜数字游戏"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// println!("The secret number is: {secret_number}");</span></span><br><span class="line">    <span class="keyword">loop</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"输入你猜的数字..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">"读取失败"</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"你猜的数字是：{guess}"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() {</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//比较</span></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) {</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">"guess &lt; secret_number"</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">"guess &gt; secret_number"</span>),</span><br><span class="line">            Ordering::Equal =&gt; {</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"You won"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="common-programming-concepts">Common Programming Concepts</h2>
<blockquote>
<p>This chapter covers concepts that appear in almost every programming
language and how they work in Rust. Many programming languages have much
in common at their core. None of the concepts presented in this chapter
are unique to Rust, but we’ll discuss them in the context of Rust and
explain the conventions around using these concepts.</p>
<p>Specifically, you’ll learn about variables, basic types, functions,
comments, and control flow. These foundations will be in every Rust
program, and learning them early will give you a strong core to start
from.</p>
</blockquote>
<h3 id="variables-and-mutability">Variables and Mutability</h3>
<p><strong>mut</strong></p>
<p>在Rust中，变量(variables)有两种类型，分为可变和不可变，具体是怎么回事，直接举例说明也许会更直观</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The value of x is: {x}"</span>);</span><br><span class="line">x= <span class="number">6</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The value of x is: {x}"</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里我们使用<code>let x</code>定义了变量的值，看起来好像没有问题，但是实际在编译的时候就会报错，编译器会提示我们变量<code>x</code>是不可变的，<code>cannot assign twice to immutable variable 'x'</code>，我们不能给变量分配第二个值。正如我们之前处理过的一样，我们只需在<code>x</code>之前加上<code>mut</code>来表达它是可变的，这样我们就能得到正确的结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The value of x is: 5</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure>

<p><strong>Constants</strong></p>
<p>Constants就是我们所常见的常量，它跟上面的区别是，constants是始终不可变的，我们使用<code>const</code>关键字声明而不是<code>let</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>Constants的声明通常采用大写字母加下划线的组合(all uppercase with
underscores between words)，它在程序运行的整个时间内都是有效的</p>
<p><strong>Shadowing</strong></p>
<p>这个词我也不知道怎么翻译比较恰当，对于<code>let</code>声明的变量，我们可以重复使用<code>let</code>来<em>shadow</em>掉我们之前定义的变量，这通常用来用来修改变量类型，不过我们还是可以通过一个例子来看一看shadowing的特点的</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = y + <span class="number">1</span>;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = y * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of y in the inner scope is: {y}"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The value of y is: {y}"</span>);</span><br></pre></td></tr></table></figure>

<p>第一行我们定义了变量<code>y</code>，它是一个不可变量，但我们可以通过重复使用<code>let</code>来改变<code>y</code>的值，也就是<em>shadowing</em></p>
<p>之后我们在大括号中(curly
brackets)再次使用<code>let</code>进行<em>shadowing</em>操作，打印出现在的值，最后在大括号外再次打印</p>
<p>结果是这样的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The value of y <span class="keyword">in</span> the inner scope is: 12</span><br><span class="line">The value of y is: 6</span><br></pre></td></tr></table></figure>

<p>我们可以发现在大括号的内部作用域中的<em>shadowing</em>操作并不能在其作用域外产生效果，也就是说这只是一个临时的操作。因此在这里，我们可以发现<em>shadowing</em>这种操作就好像拿新的物品把旧的物品给<strong>盖住</strong>了，当我们把新的拿开，旧的其实还在那(这一点会在后面进行详细说明，因为这涉及到了Rust的语言特性)</p>
<p>最后，我们还需要了解的是，<code>mut</code>和<code>shadowing</code>是两种完全不同的操作，如果我们使用<code>let mut</code>来为一个变量作声明并且赋予它可变性，我们确实不需要使用<em>shadowing</em>就可以改变它的值，但是这就不允许我们改变这个变量的类型了，如果强行改变就会导致编译器报错</p>
<h3 id="data-types">Data Types</h3>
<p>Rust将数据类型分为了两个子集：scalar 和 compound</p>
<p>Rust是一种静态类型的语言，因此它在编译的时候必须知道所有变量的类型，这一点与我所花费大量时间学过的python迥然不同(因为我并不是一个科班程序员，也没有写过任何前后端项目，对我来说开发小脚本和数据处理是更常见的应用)。Rust采用根据值和使用方式来推断我们想要使用的类型(Typescript貌似也有这样的推断机制)，因此当Rust没有办法根据已知信息推断出变量可能的类型时就需要我们声明，比如我们在小游戏代码中写到的一样</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="string">"42"</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">"Not a number!"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="scalar-types">Scalar Types</h4>
<p>Rust有四种主要的标量类型: integers, floating-point numbers, Booleans,
和
characters.这和绝大多数的编程语言是一样的，但是我认为还是很有必要重新呈现一下，因为Rust在细节上有着与其他编程语言不同的特质</p>
<p><strong>Integer Types</strong></p>
<p>整型变量分为两种，有符号数和无符号数，计算机基础课程上前几节课就会提到这个，简而言之就是有符号数使用数字开头第一位作为补码，用于表示数字的正负，因此在这种情况下，如果是一个八位的二进制数，它只能表达最多<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.016ex" height="2.088ex" role="img" focusable="false" viewBox="0 -841 2659 923"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g></g><g data-mml-node="mo" transform="translate(1158.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2159,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>，即从-128到127，因为还得分一半空间给负数。而无符号数显然就能够充分利用所有的空间<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.016ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 2659 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g></g><g data-mml-node="mo" transform="translate(1158.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2159,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>，即0到255</p>
<p>下表是Rust中所有整型的表达</p>
<table>
<thead>
<tr class="header">
<th>Length</th>
<th>Signed</th>
<th>Unsigned</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>8-bit</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr class="even">
<td>16-bit</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr class="odd">
<td>32-bit</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr class="even">
<td>64-bit</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr class="odd">
<td>128-bit</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr class="even">
<td>Arch</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody>
</table>
<p>其中<code>isize</code>和<code>usize</code>类型取决于运行程序的计算机的体系结构，如果你是64位的计算机，则为64位</p>
<p>除此以外，Rust在表达数字上还有非常方便的一点，你可以通过增加<code>_</code>来作为分隔符，让数字更容易阅读</p>
<table>
<thead>
<tr class="header">
<th>Number literals</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Decimal</td>
<td><code>98_222</code></td>
</tr>
<tr class="even">
<td>Hex</td>
<td><code>0xff</code></td>
</tr>
<tr class="odd">
<td>Octal</td>
<td><code>0o77</code></td>
</tr>
<tr class="even">
<td>Binary</td>
<td><code>0b1111_0000</code></td>
</tr>
<tr class="odd">
<td>Byte(仅<code>u8</code>)</td>
<td><code>b'A'</code></td>
</tr>
</tbody>
</table>
<p>在Rust中，默认的整型为<code>i32</code></p>
<p><strong>Floating-Point Types</strong></p>
<p>在Rust中，有两种浮点类型<code>f32</code>和<code>f64</code>，并且默认类型为<code>f64</code>，在现代CPU上，它的速度与<code>f32</code>大致相同并且能有更高的精度</p>
<p><strong>The Boolean Type</strong></p>
<p>和大多数编程语言一样，Rust中的布尔类型的两个值为<code>true</code>和<code>false</code>(这里python是一个例外)，布尔值的主要应用场景是<code>if</code>表达式</p>
<p><strong>The Character Type</strong></p>
<p>Rust中最基础的字母类型是<code>char</code>，要注意<code>char</code>要使用<strong>单引号</strong>的文本，Rust的<code>char</code>类型大小为4个字节，并且表示Unicode
Scalar
Value，因此它还可以表示ASCII以外的东西，包括中日韩文字，emoji等，细节将在后面详细讨论</p>
<h4 id="compound-types">Compound Types</h4>
<p>Rust有两种基础的复合类型：元组(tuples)和数组(arrays)</p>
<p><strong>The Tuple Type</strong></p>
<p>元组可以包含各种类型的值，拥有固定的长度，并且一旦声明就不能更改长度</p>
<p>我们可以用这样的方式生成元组</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>同样，我们也可以这样解构(destructure)元组</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br></pre></td></tr></table></figure>

<p>我们还可以使用<code>.</code>(period)跟上索引来直接访问元组中的元素</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">float_number</span> = tup.<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>The Array Type</strong></p>
<p>数组中的每个元素都必须拥有相同的类型，而且与python和其他语言不同的是，Rust中的数组长度是固定的，这和当年折磨我的C++如出一辙，不过C++在这方面更为严格</p>
<p>在Rust中，如果你希望将数据分配在stack上而不是heap上时，或希望确保始终拥有固定数量的元素时，数组非常有用。但是如果你想要像在python中那样灵活方便地操纵数组，应该使用标准库中提供的向量</p>
<p>比如像这种情况下，使用数组会更好：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">month</span> = [<span class="string">"January"</span>, <span class="string">"February"</span>, <span class="string">"March"</span>, <span class="string">"April"</span>, <span class="string">"May"</span>, <span class="string">"June"</span>, <span class="string">"July"</span>, <span class="string">"Augut"</span>, <span class="string">"September"</span>, <span class="string">"November"</span>, <span class="string">"December"</span>];</span><br></pre></td></tr></table></figure>

<p>声明数组</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>注意这里用的是分号(semicolon)，如果编译器能推断的话，不写也是可以的</p>
<p>也可以指定初始值，生成指定长度的包含相同元素的数组</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>;<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>访问数组跟python是一样的</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h3 id="functions">Functions</h3>
<h4 id="functions-1">Functions</h4>
<p>使用<code>fn</code>来声明(declare)函数</p>
<p>Rust使用<em>snake
case</em>作为函数和变量名的常规样式，即所有字母小写，单词之间添加下划线</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="title function_ invoke__">print_labeled_measurement</span>(<span class="number">5</span>, <span class="string">'h'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_labeled_measurement</span>(value: <span class="type">i32</span>, unit_label: <span class="type">char</span>) {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The measurement is: {value} {unit_label}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>大括号(curly brackets)用来告诉编译器函数体开始和结束的位置</p>
<p>通过输入函数名称和后面跟的一组括号(parentheses)来调用我们定义的函数</p>
<p>我们可以发现，我们在主函数后面定义的<code>print_labeled_measurement</code>，但是这个程序仍然可以执行(这一点在python中是做不到的)，因为Rust并不关心你在哪里定义了函数，它只关心在作用域中是否可以被调用(only
that they’re defined somewhere in a scope that can be seen by the
caller)</p>
<p><strong>Parameters</strong></p>
<p>参数也可以被更精准叫做<em>arguments</em>，但是这不重要，这在我们这儿是等价的</p>
<p>看上面的程序，我们在定义函数的时候声明了变量的类型<code>value: 32, unit_label: char</code>，这在Rust中是<strong>必须</strong>的，Rust故意设计成这样，因而编译器就可以在你根本不使用这些变量时也能知道变量的类型(前面提到的Rust有类型的推断功能，但是如果变量都没出现过，还怎么推断呢？)，而且如果编译器知道变量类型，它在返回错误信息的时候可能更有用，更利于debug</p>
<h4 id="statements-and-expressions">Statements and Expressions</h4>
<p>这是很重要的一部分内容</p>
<p>Rust是一门 expression-based 语言，我们首先要分清 statements 和
expressions</p>
<ul>
<li>Statements 是执行某些操作但不返回值的指令</li>
<li>Expressions 用来计算值的结果</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">6</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>在这里<code>let y = 6;</code>就是一个statement，以<code>;</code>作结尾表示语句完毕，因为statement不返回值，因此不能将这个语句分配给另一个变量</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> = <span class="title function_ invoke__">x</span> (<span class="keyword">let</span> <span class="variable">y</span> = <span class="number">6</span>); <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>这样的语句就是错误的，因为<code>let y = 6</code>
不返回值，所以<code>x</code>并没有任何内容可以绑定，那么什么是
expression
呢？这其中<code>6</code>就是一个expression，你可以想象成一个函数映射<code>6 -&gt; 6</code>。调用函数、调用宏(macro)都是expression，用大括号创建一个新的作用域区块也是一个expression，比如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of y is: {y}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; The value of y is: 4</span><br></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>就是一个块(block)，或者这样写可能更符合我们对表达式的认知</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = {<span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;x + <span class="number">1</span>};</span><br></pre></td></tr></table></figure>

<p>我们可以看见<code>x + 1</code>并没有加<code>;</code>，如果加了分号就被转换成了语句，这样就不会返回任何值</p>
<h4 id="functions-with-return-values">Functions with Return Values</h4>
<p>函数可以将值返回给调用它的代码，在Rust中，函数的返回值与函数体中最后的表达式(expression)是同义的(synonymous)，使用<code>return</code>关键字指定一个值来提前返回是ok的，但是大多数函数都会隐式返回最后一个表达式，我们使用<code>-&gt;</code>(arrow)并在后面声明类型就可以</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span> <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">five</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of x is: {x}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>这与<code>let x = 5</code>表达的含义相同，因为<code>5</code>在这里就是一个完整的表达式，如果加上<code>;</code>就称为了一个statement，这就回导致编译器报错，函数将返回一个<code>i32</code>，但是statement并不会去求值，因此会返回<code>()</code>，这就是一个<code>unit type</code></p>
<h3 id="comments">Comments</h3>
<p>Rust使用<code>//</code>双斜杠进行注释，这和大部分用<code>;</code>的语言相同，多行注释也是用同样的方法</p>
<p>此外，Rust中还有文档注释(Documentation
comments)，使用三个斜杠<code>///</code>，并且支持Markdown标记语言来格式化文本(喜</p>
<h3 id="control-flow">Control Flow</h3>
<p>根据条件重复运行某些代码的能力是大多数编程语言中的基本功能，在Rust中最常见的控制方法就是<code>if</code>表达式和循环</p>
<h4 id="if不同于其他语言的地方">if不同于其他语言的地方</h4>
<p>在使用<code>if</code>表达式的时候，Rust有一些与其他语言不同的地方，比如这一段代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> number {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"number is three"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>编译器是会报错的，它会告诉我们<code>number</code>必须是一个<code>bool</code>类型，当然你如果在VSCode中安装了<strong>rust-analyzer</strong>插件，会直接在编辑器中发现错误，并且能够看见<code>number</code>的类型</p>
<img src="https://mdstore.oss-cn-beijing.aliyuncs.com/markdown/image-20240324222253816.png" alt="image-20240324222253816" style="zoom:50%;">

<p>与其他语言不同，Rust不会自动尝试将非布尔类型转换为布尔类型，因此必须明确条件为布尔值，这也是Rust语言特性所突出强调的变量类型</p>
<p>当然我们也可以通过逻辑判断：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> number != <span class="number">0</span> </span><br></pre></td></tr></table></figure>

<p>这也许是更经常写的条件判断句</p>
<p>对于多种可能，Rust也采用<code>else if </code>来处理多种不同情况，我们也要注意，一旦找到第一个符合条件的情况，后面的情况即使符合条件，也不会被执行，因为Rust只执行第一个<code>true</code>条件，剩余的就不会被检查</p>
<p>当然，使用太多<code>else if</code>会导致代码混乱，如果有多个表达式，Rust也提供了<code>match</code>方法，这在我们之前的小游戏中用过了，它采用叫做<em>arm</em>的分支结构，代码可读性很好</p>
<h4 id="在let语句中使用if">在let语句中使用if</h4>
<p>这给我一种写python函数推导式的感觉</p>
<p>因为<code>if</code>属于表达式，因此它能返回值，我们可以在<code>let</code>语句的右边加上<code>if</code>用来判断分配变量</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">condition</span> = ture;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition {<span class="number">5</span>} <span class="keyword">else</span> {<span class="number">6</span>};</span><br></pre></td></tr></table></figure>

<p>在Rust中，我们要铭记一个非常重要的概念！⚠️⚠️⚠️</p>
<blockquote>
<p>Remember that blocks of code evaluate to the last expression in them,
and <strong>numbers</strong> by themselves are also expressions.</p>
<p>我们时刻要记住数字可以是一个映射f(x) = x，在这种情况下5 -&gt; 5</p>
</blockquote>
<p>整个<code>if</code>表达式的值都取决于执行哪个代码块，因此<code>if</code>的每一个臂(arm)或者分支返回的值都必须是相同的类型，如果我们将上面的情况改一下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition {<span class="number">5</span>} <span class="keyword">else</span> {<span class="string">"six"</span>};</span><br></pre></td></tr></table></figure>

<p>编译器就会报错，这在我们人类的逻辑看起来好像并无不妥，但是我们从编译器的角度思考，Rust需要在编译的时候<strong>明确</strong>知道<code>number</code>变量是什么类型，编译器知道了<code>number</code>的类型就可以在任何地方验证可用，Rust没有办法做到让<code>number</code>的类型仅在运行时确定，如果要做到这样的功能，相比编译器会更加复杂吧，并且可靠性也会降低</p>
<h4 id="loop循环">loop循环</h4>
<p>我们在之前的小游戏中就用到过<code>loop</code>了，它不需要条件就能进入循环，在循环中我们可以使用<code>break</code>来跳出循环，这在之前我们也使用过了，但实际上<code>break</code>关键字还可以携带语句，比如在这个例子中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> {</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter ==<span class="number">10</span> {</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The result is {}"</span>, result);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The result is 20</span><br></pre></td></tr></table></figure>

<p>程序输出如我们所想</p>
<h4 id="消除歧义">消除歧义</h4>
<p>Rust的循环结构有一个非常有意思的点，如果出现循环套着循环的结构，当然这在我们平时的编程中也很常见，<code>break</code>和<code>continue</code>位于内层循环，我们可以选择在循环上指定标签，然后通过在关键字上添加标签实现精准控制，消除歧义</p>
<p>循环标签采用单引号(single quote)<code>‘</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">'counting_up</span>: <span class="keyword">loop</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"count = {count}"</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">loop</span> {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"remaining = {remaining}"</span>);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> {</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">'counting_up</span>;</span><br><span class="line">            }</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"End count = {count}"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line">count = 0</span><br><span class="line">remaining = 10</span><br><span class="line">remaining = 9</span><br><span class="line">count = 1</span><br><span class="line">remaining = 10</span><br><span class="line">remaining = 9</span><br><span class="line">count = 2</span><br><span class="line">remaining = 10</span><br><span class="line">End count = 2</span><br></pre></td></tr></table></figure>

<p>我们发现<code>count</code>为2时会跳出整个循环</p>
<h4 id="while循环">while循环</h4>
<p>当然上面的代码用<code>while</code>循环写的话会简洁很多，<code>while</code>允许我们对循环的进行添加条件</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"the value is: {}"</span>, a[index]);</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>这种方法很好，但是Rust在应对这样的遍历时有更好的方法</p>
<h4 id="for循环">for循环</h4>
<p>上面的代码更容易出错，如果你减少了数组元素，但是又没有更新条件，就会发生错误。此外，我们在上面对循环条件作了检查，编译器添加了运行时代码来在循环的每次迭代中执行索引是否在数组范围内的条件检查，这会导致代码变慢</p>
<p><code>for</code>循环可以为这个集合中的每一个项目执行代码的操作</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"The value is: {element}"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>既保障了安全性又不失简介性，因此<code>for</code>循环是<code>Rust</code>中最常用的循环语句</p>
<p>当然，<code>for</code>循环也能像<code>while</code>循环一样做到按顺序生成一个数字到另一个数字之前结束的循环</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">4</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{number}"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"OVER"</span>)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">OVER</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{number}"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"OVER"</span>)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">OVER</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://limuyuan.top">Kihara Ri</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://limuyuan.top/posts/Rust%E5%85%A5%E9%97%A8(%E4%B8%80).html">https://limuyuan.top/posts/Rust入门(一).html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://limuyuan.top" target="_blank">kihara</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Rust/">Rust</a><a class="post-meta__tags" href="/tags/programming/">programming</a></div><div class="post_share"><div class="social-share" data-image="https://www.rust-lang.org/static/images/rust-logo-blk.svg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%9B%B4%E5%BA%95%E5%B1%82.html" title="C语言：更底层"><img class="cover" src="/img/default_cover3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C语言：更底层</div></div></a></div><div class="next-post pull-right"><a href="/posts/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%E3%80%81%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2%E3%80%81%E5%8D%B7%E7%A7%AF.html" title="傅立叶变换、拉普拉斯变换、卷积"><img class="cover" src="/img/default_cover5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">傅立叶变换、拉普拉斯变换、卷积</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/Rust%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6(%E4%BA%8C).html" title="Rust核心机制(二)"><img class="cover" src="https://www.rust-lang.org/static/images/rust-logo-blk.svg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-04-04</div><div class="title">Rust核心机制(二)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/Avator.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Kihara Ri</div><div class="author-info__description">春宵苦短，做且必做你认为你该做的事</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">102</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Kihara-Ri" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:limuyuan3650@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">应当做一个可嵌入式的消息盒子</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#references"><span class="toc-number">1.</span> <span class="toc-text">References</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getting-started"><span class="toc-number">2.</span> <span class="toc-text">Getting Started</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#installation"><span class="toc-number">2.1.</span> <span class="toc-text">Installation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hello-world"><span class="toc-number">2.2.</span> <span class="toc-text">Hello, World!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hello-cargo"><span class="toc-number">2.3.</span> <span class="toc-text">Hello, Cargo!</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#programming-a-guessing-game"><span class="toc-number">3.</span> <span class="toc-text">Programming a Guessing Game</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">3.1.</span> <span class="toc-text">输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">生成随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.</span> <span class="toc-text">比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.4.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%97%A0%E6%95%88%E8%BE%93%E5%85%A5"><span class="toc-number">3.5.</span> <span class="toc-text">处理无效输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overview"><span class="toc-number">3.6.</span> <span class="toc-text">Overview</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#common-programming-concepts"><span class="toc-number">4.</span> <span class="toc-text">Common Programming Concepts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#variables-and-mutability"><span class="toc-number">4.1.</span> <span class="toc-text">Variables and Mutability</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data-types"><span class="toc-number">4.2.</span> <span class="toc-text">Data Types</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#scalar-types"><span class="toc-number">4.2.1.</span> <span class="toc-text">Scalar Types</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compound-types"><span class="toc-number">4.2.2.</span> <span class="toc-text">Compound Types</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#functions"><span class="toc-number">4.3.</span> <span class="toc-text">Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#functions-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">Functions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#statements-and-expressions"><span class="toc-number">4.3.2.</span> <span class="toc-text">Statements and Expressions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#functions-with-return-values"><span class="toc-number">4.3.3.</span> <span class="toc-text">Functions with Return Values</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#comments"><span class="toc-number">4.4.</span> <span class="toc-text">Comments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#control-flow"><span class="toc-number">4.5.</span> <span class="toc-text">Control Flow</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if%E4%B8%8D%E5%90%8C%E4%BA%8E%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">4.5.1.</span> <span class="toc-text">if不同于其他语言的地方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8let%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8if"><span class="toc-number">4.5.2.</span> <span class="toc-text">在let语句中使用if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loop%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.5.3.</span> <span class="toc-text">loop循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E6%AD%A7%E4%B9%89"><span class="toc-number">4.5.4.</span> <span class="toc-text">消除歧义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.5.5.</span> <span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.5.6.</span> <span class="toc-text">for循环</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Rust%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6(%E4%BA%8C).html" title="Rust核心机制(二)"><img src="https://www.rust-lang.org/static/images/rust-logo-blk.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Rust核心机制(二)"></a><div class="content"><a class="title" href="/posts/Rust%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6(%E4%BA%8C).html" title="Rust核心机制(二)">Rust核心机制(二)</a><time datetime="2024-04-03T02:50:56.000Z" title="发表于 2024-04-03 10:50:56">2024-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Rust%E5%85%A5%E9%97%A8(%E4%B8%80).html" title="Rust入门(一)"><img src="https://www.rust-lang.org/static/images/rust-logo-blk.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Rust入门(一)"></a><div class="content"><a class="title" href="/posts/Rust%E5%85%A5%E9%97%A8(%E4%B8%80).html" title="Rust入门(一)">Rust入门(一)</a><time datetime="2024-03-22T15:56:25.000Z" title="发表于 2024-03-22 23:56:25">2024-03-22</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Rust%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6(%E4%BA%8C).html" title="Rust核心机制(二)"><img src="https://www.rust-lang.org/static/images/rust-logo-blk.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Rust核心机制(二)"/></a><div class="content"><a class="title" href="/posts/Rust%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6(%E4%BA%8C).html" title="Rust核心机制(二)">Rust核心机制(二)</a><time datetime="2024-04-03T02:50:56.000Z" title="发表于 2024-04-03 10:50:56">2024-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/%E7%AE%80%E5%8D%95bs4%E7%88%AC%E8%99%AB%E7%88%AC%E6%AD%8C%E8%AF%8D.html" title="简单bs4爬虫"><img src="https://mdstore.oss-cn-beijing.aliyuncs.com/markdown/202403311623031.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单bs4爬虫"/></a><div class="content"><a class="title" href="/posts/%E7%AE%80%E5%8D%95bs4%E7%88%AC%E8%99%AB%E7%88%AC%E6%AD%8C%E8%AF%8D.html" title="简单bs4爬虫">简单bs4爬虫</a><time datetime="2024-03-31T07:59:05.000Z" title="发表于 2024-03-31 15:59:05">2024-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/%E7%BC%96%E8%BE%91%E5%99%A8%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92(%E6%9C%AA%E5%AE%8C%E6%88%90).html" title="编辑器改造计划"><img src="/img/default_cover1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="编辑器改造计划"/></a><div class="content"><a class="title" href="/posts/%E7%BC%96%E8%BE%91%E5%99%A8%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92(%E6%9C%AA%E5%AE%8C%E6%88%90).html" title="编辑器改造计划">编辑器改造计划</a><time datetime="2024-03-30T08:24:59.000Z" title="发表于 2024-03-30 16:24:59">2024-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/%E5%9C%A8Markdown%E4%B8%AD%E6%8F%92%E5%85%A5icons.html" title="在Markdown中插入icons"><img src="https://mdstore.oss-cn-beijing.aliyuncs.com/markdown/202403292349691.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在Markdown中插入icons"/></a><div class="content"><a class="title" href="/posts/%E5%9C%A8Markdown%E4%B8%AD%E6%8F%92%E5%85%A5icons.html" title="在Markdown中插入icons">在Markdown中插入icons</a><time datetime="2024-03-29T07:32:29.000Z" title="发表于 2024-03-29 15:32:29">2024-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%9B%B4%E5%BA%95%E5%B1%82.html" title="C语言：更底层"><img src="/img/default_cover3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言：更底层"/></a><div class="content"><a class="title" href="/posts/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%9B%B4%E5%BA%95%E5%B1%82.html" title="C语言：更底层">C语言：更底层</a><time datetime="2024-03-28T06:25:08.000Z" title="发表于 2024-03-28 14:25:08">2024-03-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Kihara Ri</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">海内存知己，天涯若比邻</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 760px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 640px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/技术/&quot;);" href="javascript:void(0);">技术</a><span class="categoryBar-list-count">15</span><span class="categoryBar-list-descr">Ubuntu指南</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/logs/&quot;);" href="javascript:void(0);">logs</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr">玩转Win10</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学/&quot;);" href="javascript:void(0);">数学</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr">长篇小说连载</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover4.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/物理/&quot;);" href="javascript:void(0);">物理</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">个人日记</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover5.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/mathematics/&quot;);" href="javascript:void(0);">mathematics</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr">诗词歌赋</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover6.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Linux/&quot;);" href="javascript:void(0);">Linux</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">杂谈教程</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/万物/&quot;);" href="javascript:void(0);">万物</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/语言/&quot;);" href="javascript:void(0);">语言</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/项目/&quot;);" href="javascript:void(0);">项目</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/categories/'|| '/categories/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><!-- hexo injector body_end end --></body></html>